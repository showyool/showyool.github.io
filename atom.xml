<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Showyool&#39;s Blog</title>
  
  
  <link href="https://showyool.github.io/atom.xml" rel="self"/>
  
  <link href="https://showyool.github.io/"/>
  <updated>2020-10-22T19:04:45.719Z</updated>
  <id>https://showyool.github.io/</id>
  
  <author>
    <name>Showyool</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一次i++引发的bug</title>
    <link href="https://showyool.github.io/2020/10/19/6885187698420613127/"/>
    <id>https://showyool.github.io/2020/10/19/6885187698420613127/</id>
    <published>2020-10-18T20:45:39.000Z</published>
    <updated>2020-10-22T19:04:45.719Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，作为日常写bug修bug的我，今天给大家带来前几天刚刚修复的一个事故。不得不承认，有我的地方总是会有这么多bug。</p><div align=center><img src="http://wx1.sinaimg.cn/large/006APoFYly1gf114exyufj30b408cmy0.jpg" /></div><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>故事的开始发生在前几天，有一个不是很常用的导出功能，被用户反馈出，不管条件是怎么样，导出的数据只有一条，但是实际上根据条件查询是有很多数据，而且页面中也查询出很多数据。（这个问题已经被修复了，所以当时的Kibana日志也找不到了）于是放下手上的工作，投入其中来看这个问题。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从问题的描述中来分析，那么只可能出现在以下情况: <br /></p><ol><li>根据搜索条件查询出来的记录只有一条。</li><li>对查询出来的数据进行相关业务处理，导致最后的结果只有一条。</li><li>文件导出组件的逻辑处理之后，导致结果只有一条。<br /></li></ol><p><strong>题外话</strong> <br /><br>写到了这里，突然想到了一个经典面试题，MQ消息丢失的场景原因分析。哈哈哈，其实大致上也是这么几个角度分析。（有机会来写MQ的文章）<br /><br><strong>题外话</strong></p><div align=center><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dfb0f15b3a344a79ed83ef072b4216f~tplv-k3u1fbpfcp-zoom-1.image" width=280 /></div><p>于是就一个个来分析: </p><ol><li>找到相关业务的SQL以及对应的参数，查询可得，数据不止1条，所以第一种情况可以排除。</li><li>中间业务当中有涉及到相关权限、数据敏感等，将这些都放开之后，还是只有1条数据。</li><li>文件导出组件在接收到数据的时候，打印出的日志也显示只有一条，那么可以说明肯定中间相关业务的逻辑发生了问题。</li></ol><p>由于这段代码都是写在一整个方法里面，导致Arthas排查起来就比较困难，只好一步步设置日志进行排查。（所以，如果是一大段逻辑，建议是拆分成duoge 子方法，一来在写的时候思路明确，有一种模块化的概念，至于方法复用什么的我就不多提了，基本操作；二是一但发生问题，排查起来也会方便点，经验之谈）。<br /><br>最终定位到一个for循环里面。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>话不多说，我们直接来看代码。众所周知，我向来是一个很保护公司代码的人，所以，我在这里又不得不给大家模拟一下了。从问题的情况来看，是导出的对象记录是空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Customer数据，这里就简单模拟</span></span><br><span class="line">        List&lt;Customer&gt; customerList = Lists.newArrayList(<span class="keyword">new</span> Customer(<span class="string">&quot;Java&quot;</span>), <span class="keyword">new</span> Customer(<span class="string">&quot;Showyool&quot;</span>), <span class="keyword">new</span> Customer(<span class="string">&quot;Soga&quot;</span>));</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        String[][] exportData = <span class="keyword">new</span> String[customerList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (Customer customer : customerList) &#123;</span><br><span class="line">            exportData[index][<span class="number">0</span>] = String.valueOf(index);</span><br><span class="line">            exportData[index][<span class="number">1</span>] = customer.getName();</span><br><span class="line">            index = index++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(JSON.toJSONString(exportData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来好像也没什么的，就是将Customer集合转换成一个字符串二维数组。但是输出结果显示:<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cb6af20ea234441b8a33dbc38ef0f15~tplv-k3u1fbpfcp-watermark.image"><br>这就符合我们说的，查询出来有多条，但是输出只有1条。 <br /><br>仔细观察一下，我们可以发现，输出的数据显示都是最后一条，也就是说，Customer这个集合每次遍历的时候，都是后者将前者进行覆盖，也就是说，这个index的下标一直没有变化过，一直是0。</p><h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><p>这样看来，我们的这个自增确实有点问题，那么我们再简单来写一个模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">3</span>;</span><br><span class="line">        index = index++;</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将上面的业务逻辑简化成这样一个模型，那么这个结果毫无意外的是3。</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>那么我们执行一下javap，看看JVM字节码是如何解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">javap -c Test2</span><br><span class="line"></span><br><span class="line">Compiled from <span class="string">&quot;Test2.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">showyool</span>.<span class="title">blog_4</span>.<span class="title">Test2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.showyool.blog_4.Test2();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_3</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iload_1</span><br><span class="line">       <span class="number">3</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">       <span class="number">6</span>: istore_1</span><br><span class="line">       7: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">10</span>: iload_1</span><br><span class="line">      11: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我简单讲一下这里的JVM字节码指令（后面有机会再详细写写文章）<br /><br>首先我们需要先知道这里存在两个概念，操作数栈和局部变量表，这两者是存在虚拟机栈当中栈帧（stack frame)当中的一些数据结构，如图: </p><div align=center><img src="//p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee0a8fdfbbb74b2c866bf0c21bde8d68~tplv-k3u1fbpfcp-watermark.image" width=280 /></div>我们可以简单的理解为，操作数栈的作用是存放数据并且在栈中进行计算数据，而局部变量表则是存放变量的一些信息。<br />然后我们来看看上面的指令: <br />0: iconst_3 (先将常量3压入栈) <div align=center><img src="//p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb9d0b45d4164cf58f86d8c1795adadf~tplv-k3u1fbpfcp-watermark.image" width=280 /></div>1: istore_1 (出栈操作，将值赋给第一个参数，也就是将3赋值给index) <br /><div align=center><img src="//p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3f22cc6d6814c78b864d57c79f9fb95~tplv-k3u1fbpfcp-watermark.image" width=280 /></div>2: iload_1  (将第一个参数的值压入栈，也就是将3入栈，此时栈顶的值为3) <br /><div align=center><img src="//p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/533ecdf78625491fa466ffacfe78e653~tplv-k3u1fbpfcp-watermark.image" width=280 /></div>3: iinc 1, 1 (将第一个参数的值进行自增操作，那么此时index的值是4) <br /><div align=center><img src="//p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a915991bd0b482b8da4eb0507bb5be9~tplv-k3u1fbpfcp-watermark.image" width=280 /></div>6: istore_1 (出栈操作，将值赋给第一个参数，也就是将3赋值给index) <br /><div align=center><img src="//p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3f22cc6d6814c78b864d57c79f9fb95~tplv-k3u1fbpfcp-watermark.image" width=280 /></div>也就是说index这个参数的值是经历了index->3->4->3，所以这样一轮操作之后，index又回到了一开始赋值的值。<h2 id="延伸一下"><a href="#延伸一下" class="headerlink" title="延伸一下"></a>延伸一下</h2><p>这样一来，我们发现，问题其实出在最后一步，在进行运算之后，又将原先栈中记录的值重新赋给变量，覆盖掉了<br>如果我们这样写: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">3</span>;</span><br><span class="line">        index++;</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compiled from <span class="string">&quot;Test2.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">showyool</span>.<span class="title">blog_4</span>.<span class="title">Test2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.showyool.blog_4.Test2();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_3</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">       5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       <span class="number">8</span>: iload_1</span><br><span class="line">       9: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这里就没有最后一步的istore_1，那么在iinc之后，index的值就变成我们预想的4。<br /><br>还有一种情况，我们来看看: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">3</span>;</span><br><span class="line">        index = index + <span class="number">2</span>;</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compiled from <span class="string">&quot;Test2.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">showyool</span>.<span class="title">blog_4</span>.<span class="title">Test2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.showyool.blog_4.Test2();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_3</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iload_1</span><br><span class="line">       <span class="number">3</span>: iconst_2</span><br><span class="line">       <span class="number">4</span>: iadd</span><br><span class="line">       <span class="number">5</span>: istore_1</span><br><span class="line">       6: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       <span class="number">9</span>: iload_1</span><br><span class="line">      10: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>0: iconst_3 (先将常量3压入栈) <br /><br>1: istore_1 (出栈操作，将值赋给第一个参数，也就是将3赋值给index) <br /><br>2: iload_1  (将第一个参数的值压入栈，也就是将3入栈，此时栈顶的值为3) <br /><br>3: iconst_2 (将常量2压入栈, 此时栈顶的值为2，2在3之上) <br /><br>4: iadd (将栈顶的两个数进行相加，并将结果压入栈。2+3=5，此时栈顶的值为5) <br /><br>5: istore_1 (出栈操作，将值赋给第一个参数，也就是将5赋值给index) <br /></p><p>看到这里各位观众老爷肯定会有这么一个疑惑，为什么这里的iadd加法操作之后，会影响栈里面的数据，而先前说的iinc不是在栈里面操作？好的吧，我们可以看看JVM虚拟机规范当中，它是这么描述的:</p><blockquote><p>指令iinc对给定的局部变量做自增操作，这条指令是少数几个执行过程中完全不修改操作数栈的指令。它接收两个操作数：<br>第1个局部变量表的位置，第2个位累加数。比如常见的i++,就会产生这条指令</p></blockquote><p>看到这里，我们知道，对于一般的加法操作之后复制没啥问题，但是使用i++之后，那么此时栈顶的数还是之前的旧值，如果此刻进行赋值就会回到原来的旧值，因为它并没有修改栈里面的数据。所以先前那个bug，只需要进行自增不赋值就可以修复了。<br><br /></p><div align=center><img src="//wx2.sinaimg.cn/large/ceeb653ely1gee86ffyvdg207c07ctzo.gif" width=280 /></div><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢各位能够看到这里，以上就是我处理这个bug的全部过程。虽然这只是一个小bug，但是这一个小小的bug还是值得学习和思考的。今后还会继续分享我所发现的bug以及知识点，如果我的文章对你有所帮助，还希望各位大佬$\color{red}{点个关注}$$\color{red}{点个赞}$，再次感谢大家的支持！<br /><br>这里也附上我的Github地址:<a href="https://github.com/showyool/juejin.git">https://github.com/showyool/juejin.git</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家好，作为日常写bug修bug的我，今天给大家带来前几天刚刚修复的一个事故。不得不承认，有我的地方总是会有这么多bug。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&quot;http://wx1.sinaimg.cn/large/006APoFYly1gf1</summary>
      
    
    
    
    
    <category term="Java" scheme="https://showyool.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>可能我这辈子也不会用Guava的Partition了</title>
    <link href="https://showyool.github.io/2020/10/08/6881281564060155912/"/>
    <id>https://showyool.github.io/2020/10/08/6881281564060155912/</id>
    <published>2020-10-08T08:12:40.000Z</published>
    <updated>2020-10-22T18:46:34.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="又写BUG了"><a href="#又写BUG了" class="headerlink" title="又写BUG了"></a>又写BUG了</h2><p>上回书说道，我写的《<a href="https://juejin.im/post/6875124307605864461">这可能是你从未见过如此优雅的写法</a>》里面的方法是为了将非业务和业务逻辑进行解耦出来，于是周围小伙伴觉得不错也都开始使用起来，这颇让人感到很有成就感。于是大家都开始纷纷使用起来。既然话已经说到了这里，想必各位也已经知道接下来肯定是搞出了bug。<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c81cfcb0b27145bda36e80dce9fd0077~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="故事的开始"><a href="#故事的开始" class="headerlink" title="故事的开始"></a>故事的开始</h2><p>有一天，突然有个小伙伴说，有一个查询商品的dubbo接口报了NoSuchElementException的错误，然后在kibana的堆栈日志这边看到的是我之前提供的那个公共方法的一行，这就引起了我的注意<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27678fee451148c5860ba0d52c1f8028~tplv-k3u1fbpfcp-zoom-1.image"><br>那么我们来看看这是在哪一行<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/018b427c74a74e70b3f490b397f7cb99~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="常见的NoSuchElementException原因"><a href="#常见的NoSuchElementException原因" class="headerlink" title="常见的NoSuchElementException原因"></a>常见的NoSuchElementException原因</h2><p>NoSuchElementException这个错误是不是十分眼熟？没错，各位有心的话，在网上会搜到很多这种错误，无非就是在循环迭代中多次使用了next()的原因，例如: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;wo&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ni&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ta&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">     iterator.next();</span><br><span class="line">     System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97c0a208ca4341348db25c4f48bf5612~tplv-k3u1fbpfcp-zoom-1.image"><br>我们可以深入一下看看这个ArrayList里面的第862行（本人使用的JDK版本为1.8.181，不同版本之间的行数可能不一样）<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cbedcb4b95748f7a1084695ef856082~tplv-k3u1fbpfcp-zoom-1.image"><br>可以看到这里在执行next()方法的时候，会进行游标数的检查。可以发现，在上面的例子中，由于每次for循环当中多执行了一次next()，使得每次循环的游标移动了两次，所以就会造成这个问题。具体的各位可以自己DEBUG看看。<br /></p><h2 id="回归主线"><a href="#回归主线" class="headerlink" title="回归主线"></a>回归主线</h2><p>那么，这次的原因是不是也是这个地方发生的呢，由于公司政策要求，我这边就不方便贴出相关的业务代码（这可是要被开除的），但是这边也没有使用迭代器的循环写法，而是用了简单的增强for循环，也就不会出现像上面的多次调用next()的情况。<br /><br>于是只好本地进行模拟:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; all = Lists.newArrayList(<span class="string">&quot;ki1&quot;</span>);</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> CommonDoPartition&lt;&gt;().partitionToQuery4Map(<span class="number">500</span>, all, outerIds -&gt; returnMap(outerIds));</span><br><span class="line">    System.out.println(JSON.toJSONString(map));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">returnMap</span><span class="params">(List&lt;String&gt; all)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = Maps.newHashMap();</span><br><span class="line">    map.put(<span class="string">&quot;ki1&quot;</span>, <span class="string">&quot;ki1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后发现，并没有报错。<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ea2833b9f9d4aae9d18dc0e42023b9c~tplv-k3u1fbpfcp-zoom-1.image"><br>这可真的是吓坏本宝宝了。<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a7516a91f7a459f9ebeb145d170dbb1~tplv-k3u1fbpfcp-zoom-1.image"><br>在那个出错的代码当中，也只是在lambda表达式中调用一个业务方法。其他的部分完全一致，那么根据控制变量法（当然，运行的机器、容器、环境等这些暂时先不考虑），是不是出问题的地方在于这个业务代码呢，于是拉着小伙伴看了下这里面的业务逻辑。果真，发现了一些端倪。在这里业务代码中，有对这个入参的all进行过删减，于是我也进行一波小小的测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; all = Lists.newArrayList(<span class="string">&quot;ki1&quot;</span>);</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> CommonDoPartition&lt;&gt;().partitionToQuery4Map(<span class="number">500</span>, all, outerIds -&gt; returnMap(outerIds));</span><br><span class="line">    System.out.println(JSON.toJSONString(map));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">returnMap</span><span class="params">(List&lt;String&gt; all)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = Maps.newHashMap();</span><br><span class="line">    all.remove(<span class="string">&quot;ki1&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;ki1&quot;</span>, <span class="string">&quot;ki1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然报了这个错误，这个和kibana上面的错误是一样的。<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e9a7af2f471478f840692135104623e~tplv-k3u1fbpfcp-zoom-1.image"><br>那么接下来我们来深入一下代码，为什么会发生这样的错误。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93ab6b0186034787a9acb06b5e07db42~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="增强的for循环"><a href="#增强的for循环" class="headerlink" title="增强的for循环"></a>增强的for循环</h2><p>增强的for循环在我们的日常书写中是十分常见的写法，当我们不关心list当中的序列而只是依次迭代遍历对象的时候，就会使用这种写法。当然这只是JVM层面将其包装成固定的写法罢了，在具体的解释上，依旧还是依据迭代器的流程。<br /><br>例如这样一段简单的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过javap的解释之后，截取部分图片<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14d582e3fa634189a7530a1f6c2160ab~tplv-k3u1fbpfcp-zoom-1.image"><br>可以看到，这里还是使用迭代器的写法去进行遍历，通过next()方法获取到对象。</p><h2 id="继续回归主线"><a href="#继续回归主线" class="headerlink" title="继续回归主线"></a>继续回归主线</h2><p>但是为什么要讲述上面这些东西呢？<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/797b06742cd245a4a24ca307bb39411a~tplv-k3u1fbpfcp-zoom-1.image"><br>我们来看下报错这边的信息，可以看到最后一行的堆栈是停留在</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java<span class="selector-class">.util</span>.NoSuchElementException</span><br><span class="line">at java<span class="selector-class">.util</span>.AbstractList<span class="variable">$Itr</span>.next(AbstractList<span class="selector-class">.java</span>:<span class="number">364</span>)</span><br><span class="line">at com<span class="selector-class">.example</span><span class="selector-class">.demo</span><span class="selector-class">.consume</span><span class="selector-class">.CommonDoPartition</span>.partitionToQuery4Map(CommonDoPartition<span class="selector-class">.java</span>:<span class="number">67</span>)</span><br><span class="line">at com<span class="selector-class">.example</span><span class="selector-class">.demo</span><span class="selector-class">.consume</span><span class="selector-class">.CommonDoPartition</span>.main(CommonDoPartition<span class="selector-class">.java</span>:<span class="number">78</span>)</span><br></pre></td></tr></table></figure><p>看看AbstractList的364行<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e50f2199aad747768c8eed83158b2c76~tplv-k3u1fbpfcp-zoom-1.image"><br>可以看到，这里是因为报了IndexOutOfBoundsException的异常，然后抛出了NoSuchElementException异常。不同于常见的NoSuchElementException异常错误（示例1的代码），这里是使用了内部类当中的next()方法。<br /><br>那么既然会报错这个错误，问题就在于这里面的get方法。这里的get方法是一个抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><p>那么我们可以使用IDEA的Diagrams功能可以看一下继承关系<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e1eef6d9a10414bba526ccda656d3f3~tplv-k3u1fbpfcp-zoom-1.image"><br>看一下get的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  checkElementIndex(index, size());<span class="comment">// 进行安全检查</span></span><br><span class="line">  <span class="keyword">int</span> start = index * size;</span><br><span class="line">  <span class="keyword">int</span> end = Math.min(start + size, list.size());</span><br><span class="line">  <span class="keyword">return</span> list.subList(start, end);<span class="comment">// 通过subList进行部分数据的截取</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取size大小，这里其实是向上取整</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> IntMath.divide(list.size(), size, RoundingMode.CEILING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么造成IndexOutOfBoundsException异常也是由于checkElementIndex这个方法抛出来的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkElementIndex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> index, <span class="keyword">int</span> size, <span class="meta">@Nullable</span> String desc)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Carefully optimized for execution by hotspot (explanatory comment above)</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(badElementIndex(index, size, desc));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里是不是就突然明白了！Guava当中Partition的做法是通过一整个list的数据截取，其实也是一种分页的处理方式。那么倘若在后续的业务代码中对这一整个数据进行了删减，那么这里的size()的取值就不准了,造成整个get的数据就不符预测值了。<br /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么现在我们来总结一下这里的流程: <br /></p><ol><li>增强的for循环会解释成hasNext()和next()进行迭代遍历；</li><li>next()当中的get()方法其实是进行list元素列表的数据截取，可理解为分页；</li><li>get()方法会进行数组越界判断，当list数据删减的时候，size()方法的返回值不是固定值。</li><li>每一次迭代都会将游标cursor进行+1，当list数据删减的时候，调用get()进行数组越界判断就会发生IndexOutOfBoundsException异常，继而在next()方法当中抛出NoSuchElementException异常。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5434f16702974fee88a5f37ade513984~tplv-k3u1fbpfcp-zoom-1.image"></li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决的思路无非是两点:</p><ol><li>控制业务调用层面禁止对原数据列表的删除。（但是由于业务场景的复杂性，这点比较难以控制，所以不太推荐)</li><li>在这种场景下不再使用Guava的Partition，自己改写一份数据分隔的工具类。<br />可以发现，Guava的数据自始至终只有一份，也没有对原数据进行保护，就会造成下游业务对源数据进行破坏。那么也给了我们一个思路，那就是需要为原数据留下一个备份。所以我自己又写了一个工具类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubListIterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原数据列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; dataList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分隔单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> subSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> nextIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> listSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;T&gt;&gt; subLists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubListIterator</span><span class="params">(List&lt;T&gt; dataList, <span class="keyword">int</span> subSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dataList != <span class="keyword">null</span>)&#123;</span><br><span class="line">            listSize = dataList.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.dataList = dataList;</span><br><span class="line">        <span class="keyword">this</span>.subSize = subSize;</span><br><span class="line"></span><br><span class="line">        initSubLists();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSubLists</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listSize &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;T&gt; iterator = dataList.iterator();</span><br><span class="line"></span><br><span class="line">        List&lt;T&gt; subDataList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            T next = iterator.next();</span><br><span class="line"></span><br><span class="line">            subDataList.add(next);</span><br><span class="line">            <span class="keyword">if</span> (index % subSize == <span class="number">0</span> || listSize == index) &#123;</span><br><span class="line">                subLists.add(subDataList);</span><br><span class="line">                subDataList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subLists.size() &gt; nextIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> subLists.get(nextIndex++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;不支持该操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>这里也附上我的Github地址:https://github.com/showyool/juejin.git## 最后感谢各位能够看到这里，以上就是我处理这个bug的全部过程。今后还会继续分享我所发现的bug以及知识点，如果我的文章对你有所帮助，还希望各位大佬$\color{red}{点个关注}$$\color{red}{点个赞}$，再次感谢大家的支持！<br /></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;又写BUG了&quot;&gt;&lt;a href=&quot;#又写BUG了&quot; class=&quot;headerlink&quot; title=&quot;又写BUG了&quot;&gt;&lt;/a&gt;又写BUG了&lt;/h2&gt;&lt;p&gt;上回书说道，我写的《&lt;a href=&quot;https://juejin.im/post/687512430760</summary>
      
    
    
    
    
    <category term="Java" scheme="https://showyool.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>这可能是你从未见过如此优雅的写法</title>
    <link href="https://showyool.github.io/2020/09/22/6875124241813995533/"/>
    <id>https://showyool.github.io/2020/09/22/6875124241813995533/</id>
    <published>2020-09-21T17:53:52.000Z</published>
    <updated>2020-10-22T18:43:51.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看到这样的标题，第一反应是不是那个“渣渣辉”在电脑屏幕中挥舞着大砍刀，听着古天乐说着，“这是你从未玩过的全新版本”。当然，这并不是标题党，既然“这是你从未玩过的全新版本”，那么“是兄弟就来看我的文章”。（不是兄弟也请留步，嘤嘤嘤）<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/809dadaa2a94491cac5be25e641066b5~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在对公司一个几百年没有更新维护旧项目进行功能开发的时候，由于当初开发这个项目的人早已各奔前程，也没有留下什么可视性的文档，所以只能从一些代码以及注释中尽可能地摸索这个项目的系统架构以及对应的业务功能，这无疑是一件十分头疼的事情（看别人的代码和看几个月前自己的代码就像是闻SHI一样）。<br /><br>看了几遍下来，大多数的代码写的都不堪直视，甚至连基本的格式化代码也没有，但是其中有一段的代码却引起了我的注意，也是因为这段代码才引起了我的思考，也是就有了这篇文章。</p><h2 id="到底是什么样的代码呢"><a href="#到底是什么样的代码呢" class="headerlink" title="到底是什么样的代码呢"></a>到底是什么样的代码呢</h2><p>话不多说，直接上代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AbstractSpinBusiness() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompanyProfile updateProfile = getProfileForUpdateConf(staff, attrMap);</span><br><span class="line">        <span class="keyword">return</span> companyProfileDao.updateCompanyProfileConf(updateProfile) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.spin(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>简单介绍下，这段的意思是执行handle()里面的方法，并且设置了5次重试限制。<br /><br>然后我们再来看看AbstractSpinBusiness这个抽象类<br /><br><strong>AbstractSpinBusiness.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSpinBusiness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spin</span><span class="params">(<span class="keyword">int</span> times)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(handle())&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.debug(String.format(<span class="string">&quot;spin重试%s&quot;</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行主体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true:执行成功,不需要重试  false:执行失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，好像也不过只是对AbstractSpinBusiness当中的handle的实现，并且运用在spin方法当中。可能细心的同学已经发现了这使用了模板的设计模式，如果能够发现，那么给你点个赞；如果没能发现，问题也不大，因为我在这里也并非是来讲模板设计模式。当然，模板设计模式也是十分重要且优秀的写法，在抽象业务、架构当中用的是遍地开花！</p><h2 id="那么这个写法很优雅吗"><a href="#那么这个写法很优雅吗" class="headerlink" title="那么这个写法很优雅吗"></a>那么这个写法很优雅吗</h2><p>回想一下我们最早学习JDBC的时候，我们需要手动获取Connection，需要将参数设置到PreparedStatement当中，执行之后需要将对象再包装成我们想要的数据格式，这一系列的操作下来，我们可以发现，真正跟业务相贴切的就只是那一条SQL而已，其他的工作都只是一个辅助工作。<br /><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a2c842956c8485697fae3a9a041eeca~tplv-k3u1fbpfcp-zoom-1.image"></p><p>所以，像MyBatis、Hibernate等这类ORM框架才会孕育而生。开发人员在使用这些框架的时候，只需要关心我们自己的业务。例如MyBatis，我们只需要写好业务的SQL以及对应的Mapper，那么整合到业务的Service当中就可以，而其他的操作已经封装在框架中无感知执行。<br /></p><p>回归到我们刚开始的那段代码当中。不难发现这简单的代码中，其实蕴含着同样的思想，那就是将业务代码和非业务代码独立开来。试想，如果有其他地方也需要使用类似的重试逻辑，那么是否又需要写一套重试的代码呢？<br /><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30231d3b92a3400582939fd642bf35c9~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>沿着这样的思路，在最近一次优化中使用了相同的写法。<br />目前系统中存在一些慢SQL，SQL的本身是比较简单，EXPLAIN执行计划当中也没有什么问题，就只是单纯的rows比较多。问题在于业务中产生大量的参数，导致in里面的数据太多，造成SQL执行效率变低。那么比较直接的优化就是控制这里的参数，进行分批处理。（当然这里就不考虑网上说的子查询或者是eq_range_index_dive_limit参数之类）<br><br /></p><h2 id="要是你会怎么写"><a href="#要是你会怎么写" class="headerlink" title="要是你会怎么写"></a>要是你会怎么写</h2><p>要是没有前面的引子，我想大家的代码大概会是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PARTITION_SIZE = <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里就模拟是业务参数</span></span><br><span class="line">        List&lt;Long&gt; paramIds = Lists.newArrayList(<span class="number">1L</span>,<span class="number">2L</span>,<span class="number">3L</span>);</span><br><span class="line">        <span class="comment">// 进行分隔</span></span><br><span class="line">        List&lt;List&lt;Long&gt;&gt; partitionParamIds = Lists.partition(paramIds, PARTITION_SIZE);</span><br><span class="line">        List&lt;Object&gt; resultList = Lists.newArrayListWithExpectedSize(paramIds.size());</span><br><span class="line">        partitionParamIds.forEach(partition -&gt; &#123;</span><br><span class="line">            <span class="comment">// 执行具体的DAO操作，当然这里也是模拟</span></span><br><span class="line">            resultList.addAll(<span class="keyword">new</span> ObjectDao().getList(partition));</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(resultList.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectDao</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 都说了是模拟模拟，不要挑刺了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getList</span><span class="params">(List&lt;Long&gt; paramIds)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; resultList = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span> (Long paramId : paramIds) &#123;</span><br><span class="line">            resultList.add(paramId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这样写本身也是比较简单整洁的，但是有没有发现，这里切片的动作和具体的业务代码还是混杂在一起，做不到一定意义上的职责分明。那是不是可以提供一个辅助类来做这些事情呢，所以我改写下。<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbdb46fc19004aaaaf86aef31dcb75ba~tplv-k3u1fbpfcp-zoom-1.image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里就模拟是业务参数</span></span><br><span class="line">        List&lt;Long&gt; paramIds = Lists.newArrayList(<span class="number">1L</span>,<span class="number">2L</span>,<span class="number">3L</span>);</span><br><span class="line">        List&lt;Object&gt; resultList = <span class="keyword">new</span> CommonDoPartition&lt;&gt;().partitionToQuery(paramIds,</span><br><span class="line">                partition -&gt; <span class="keyword">new</span> ObjectDao().getList(partition));</span><br><span class="line">        System.out.println(resultList.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 都说了是模拟模拟，不要挑刺了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getList</span><span class="params">(List&lt;Long&gt; paramIds)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; resultList = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span> (Long paramId : paramIds) &#123;</span><br><span class="line">            resultList.add(paramId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了一个CommonDoPartition类，我们来看下它是怎么实现的<br /><br><strong>CommonDoPartition.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonDoPartition</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(CommonDoPartition.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PARTITION_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T, R&gt; <span class="function">List&lt;R&gt; <span class="title">partitionToQuery</span><span class="params">(<span class="keyword">int</span> partitionSize, List&lt;T&gt; all, Function&lt;List&lt;T&gt;, List&lt;R&gt;&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(all)) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;no data to query&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Lists.newArrayList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;T&gt;&gt; partitions = Lists.partition(all, partitionSize);</span><br><span class="line">        List&lt;R&gt; result = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;T&gt; list : partitions) &#123;</span><br><span class="line">            List&lt;R&gt; resultList = function.apply(list);</span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(resultList)) &#123;</span><br><span class="line">                result.addAll(resultList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T, R&gt; <span class="function">List&lt;R&gt; <span class="title">partitionToQuery</span><span class="params">(List&lt;T&gt; all, Function&lt;List&lt;T&gt;, List&lt;R&gt;&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.partitionToQuery(PARTITION_SIZE, all, function);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，分片的操作放到了这个公共方法当中，于是业务方只需要用lambda表达式支持他想要的业务逻辑就可以了，非业务性质工作都可以由这个工具类来完成。</p><h2 id="再来扩展一下"><a href="#再来扩展一下" class="headerlink" title="再来扩展一下"></a>再来扩展一下</h2><p>既然实现了查询操作，同样也可以搞一下执行操作<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f42e23cc29f4f11960db9194a4ba204~tplv-k3u1fbpfcp-zoom-1.image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partitionToDo</span><span class="params">(<span class="keyword">int</span> partitionSize, List&lt;T&gt; all, Consumer&lt;List&lt;T&gt;&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(all)) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;no data to consume&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;T&gt;&gt; partitions = Lists.partition(all, partitionSize);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;T&gt; list : partitions) &#123;</span><br><span class="line">        consumer.accept(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partitionToDo</span><span class="params">(List&lt;T&gt; all, Consumer&lt;List&lt;T&gt;&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.partitionToDo(PARTITION_SIZE, all, consumer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T, R&gt; <span class="function"><span class="keyword">void</span> <span class="title">partitionToQueryAndDo</span><span class="params">(<span class="keyword">int</span> partitionSize, List&lt;T&gt; all, Function&lt;List&lt;T&gt;, List&lt;R&gt;&gt; function, Consumer&lt;List&lt;R&gt;&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(all)) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;no data to consume&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;T&gt;&gt; partitions = Lists.partition(all, partitionSize);</span><br><span class="line">    List&lt;R&gt; resultList;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;T&gt; list : partitions) &#123;</span><br><span class="line">        resultList = function.apply(list);</span><br><span class="line">        consumer.accept(resultList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T, R&gt; <span class="function"><span class="keyword">void</span> <span class="title">partitionToQueryAndDo</span><span class="params">(List&lt;T&gt; all, Function&lt;List&lt;T&gt;, List&lt;R&gt;&gt; function, Consumer&lt;List&lt;R&gt;&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.partitionToQueryAndDo(PARTITION_SIZE, all, function, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的partitionToDo是分批去执行某些任务，partitionToQueryAndDo是结合了之前的分批查询某些数据，并且对这些数据进行操作。这些都是可以组合起来的例子。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>当然，本人也能力有限，也不见得能将大多数的场景进行抽象、组合、归纳，只是觉得在平时的开发中，光写业务光写代码，缺少了自己的思考以及那些优秀的设计思路和理念的话，总归还是无法达到自我提升的程度。本文也只是我在平时工作中的一些小小思考，也还算是一点小小的总结，也仅供大家参考。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91468e5a44a14a55b29ad560d44f4b5a~tplv-k3u1fbpfcp-zoom-1.image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;看到这样的标题，第一反应是不是那个“渣渣辉”在电脑屏幕中挥舞着大砍刀，听着古天乐说着，“这是你从未玩过的全新版本”。当然，这并不是标题党，既</summary>
      
    
    
    
    
    <category term="Java" scheme="https://showyool.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>不是吧，还有人不知道三目运算符的BUG</title>
    <link href="https://showyool.github.io/2020/09/15/6872738517798584328/"/>
    <id>https://showyool.github.io/2020/09/15/6872738517798584328/</id>
    <published>2020-09-15T07:39:49.000Z</published>
    <updated>2020-10-22T08:48:24.403Z</updated>
    
    <content type="html"><![CDATA[<p>三目运算符一直是众多开发者信手拈来的一种写法，它简化了if-else的臃肿的写法，而是用一行代码替代，就感觉无形之中秀了一把。<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9088deb2a1d64625b0d1a9928c5e5687~tplv-k3u1fbpfcp-zoom-1.image"><br>殊不知，这么帅气的代码也暗藏着一个BUG。</p><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>头天晚上发布了一个功能，本以为是波澜不惊的一个需求，结果第二天kibana打出了成吨的NPE日志。这些NPE日志大多都不约而同都指向了我写的一行代码，我立马推了下我的眼镜，开始排查起来了。<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1962e052977442ca94f8ccae01dfb9b8~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd4d15e03a6648a9836527c0b86e9645~tplv-k3u1fbpfcp-zoom-1.image"><br>Kibana的堆栈日志定位在第899行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resultMap.put(<span class="string">&quot;unAuditPurchaseOrder&quot;</span>, switchConf == <span class="keyword">null</span> ? <span class="number">0</span> : switchConf.getUnAuditPurchaseOrder());</span><br></pre></td></tr></table></figure><p>1.检查了resultMap，它在上面有实例化，不可能为空。<br /><br>2.检查switchConf，但是在这里有判空，也不会报错。<br>那是怎么回事？？？？<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3401cb5ca9f140e98b87b151f8d2649f~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="继续排查"><a href="#继续排查" class="headerlink" title="继续排查"></a>继续排查</h2><p>既然肉眼看不出，那么只能找一台测试机，用一下Arthas看一下具体的情况。（线上慎用，因为可能会造成卡顿）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace com.aaa.bbb.ccc.ddd.eee.CustomerButtonService getPurchaseConfig -n 5 &#x27;1==1&#x27; --skipJDKMethod false</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a20156d1b7c149f18c83f97303ff348e~tplv-k3u1fbpfcp-zoom-1.image"><br>果然，这里就发现了端倪。<br>这里竟然执行了intValue()！也就是说如果<code>switchConf.getUnAuditPurchaseOrder()</code>这个是null，那么就很明显发生了NPE。</p><h2 id="看一下字节码"><a href="#看一下字节码" class="headerlink" title="看一下字节码"></a>看一下字节码</h2><p>为了显现效果，我换一个简单的程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer i = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="number">1</span> != <span class="number">1</span> ? <span class="number">0</span> : i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位到class文件目录，执行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c -l <span class="keyword">Test</span></span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a54e3c77b9874d86a6efb6b4e50db067~tplv-k3u1fbpfcp-zoom-1.image"></p><p>然后我又改了一下程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer i = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="number">1</span> == <span class="number">1</span> ? <span class="number">0</span> : i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次运行并不会报错，看一下它的JVM指令:<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfd72f4a137240e4865a0774bd43e19a~tplv-k3u1fbpfcp-zoom-1.image"><br>因为三目运算符的结果是前者的逻辑，即返回一个常量0。</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>由上面的实验可以发现，JVM在解释三目运算符的时候，会对两个逻辑语句进行数据类型校验，按照基本数据类型为准。实验中，数据类型是基本数据类型，所以，如果逻辑走到了后者，那么就会进行自动的拆箱。这个隐式的操作就是造成这个BUG的原因。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f078e9ebc9344138bb678036c14c79fc~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>既然知道原因了，那么只要统一数据类型就行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer i = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="number">1</span> != <span class="number">1</span> ? <span class="keyword">new</span> Integer(<span class="number">0</span>) : i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后按照惯例，我们还是看一下他的JVM指令:<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/007ce4e40961419dae7a9c9f3e92e454~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><p>后来在无意之中发现，原来这个例子在《阿里巴巴开发手册》当中也有被记录<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2146b099ffdf4abfa82fe526187b8547~tplv-k3u1fbpfcp-zoom-1.image"><br>其实说的也是一回事情！<br /></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>最后,虽然问题是解决了，但我还是被测试同学记录了一下黑名单，这锅得背~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;三目运算符一直是众多开发者信手拈来的一种写法，它简化了if-else的臃肿的写法，而是用一行代码替代，就感觉无形之中秀了一把。&lt;br&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9088deb2a1</summary>
      
    
    
    
    
    <category term="Java" scheme="https://showyool.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
